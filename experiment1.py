import re
import glob
import json
import argparse
from pprint import pprint
from distutils.util import strtobool
from datetime import datetime
from itertools import product
from collections import defaultdict
import pathlib

import numpy as np

from utils import dump_results
import generate_appm
import sampling
import recovery

pathlib.Path('./data/experiment1/graphs').mkdir(parents=True, exist_ok=True)
pathlib.Path('./data/experiment1/samples').mkdir(parents=True, exist_ok=True)
pathlib.Path('./data/experiment1/recovery').mkdir(parents=True, exist_ok=True)

def bool_type(x):
  return bool(strtobool(x))

DEFAULT_SAMPLING_METHOD = "RandomWalkSampling"

def parse_graph_generate_args():
  parser = argparse.ArgumentParser("Experiment 1: Graph generation")

  parser.add_argument("--seed", type=int, default=None, help="Random seed")

  parser.add_argument("--p",
                      type=float,
                      default=3e-1,
                      help=("Parameter p for assortative planted partition"
                            " model (APPM), specifying the probability that"
                            " two nodes i,j out of the same cluster are"
                            " connected by an edge"))

  parser.add_argument("--q",
                      type=float,
                      default=5e-2,
                      help=("Parameter p for assortative planted partition"
                            " model (APPM), specifying the probability that"
                            " two nodes i,j out of two different clusters are"
                            " connected by an edge"))

  parser.add_argument("--cluster_sizes",
                      type=int,
                      nargs='+',
                      default=[10, 20, 30, 40],
                      help=("Parameter p for assortative planted partition"
                            " model (APPM), specifying the probability that"
                            " two nodes i,j out of two different clusters are"
                            " connected by an edge"))

  parser.add_argument("--num_graphs",
                      type=int,
                      default=100,
                      help="Number of graphs to generate")

  parser.add_argument("--cull_disconnected",
                      action="store_true",
                      dest="cull_disconnected",
                      default=True,
                      help="Cull nodes that are not connected to the main"
                           " graph")

  parser.add_argument("--no_cull_disconnected",
                      action="store_false",
                      dest="cull_disconnected",
                      help="Use to leave nodes that are not connected to the"
                           " main graph")

  parser.set_defaults(cull_disconnected=True)

  parser.add_argument("--results_base",
                      default="./data/experiment1/graphs",
                      type=str,
                      help="Directory to write graphs to.")

  args, unknown = parser.parse_known_args()

  return vars(args)

def parse_sampling_args():
  parser = argparse.ArgumentParser("Experiment 1: Graph sampling")

  parser.add_argument("--seed", type=int, default=None, help="Random seed")

  parser.add_argument("--Ls",
                      type=int,
                      nargs='+',
                      default=[20],
                      help=("Values for random walk length L to run experiments"
                            " for. The complete parameter space to run the"
                            " experiments for is generated by taking cartesian"
                            " product of Ls and other parameters (Ms)"))

  parser.add_argument("--Ms",
                      type=int,
                      nargs='+',
                      default=[10],
                      help=("Values for sampling budget M to run experiments"
                            " for. The complete parameter space to run the"
                            " experiments for is generated by taking cartesian"
                            " product of Ms and other parameters (Ls)"))


  parser.add_argument("--graph_file_pattern",
                      type=str,
                      default="./data/experiment1/graphs/*.json",
                      help=("Run experiment for the graphs matching the"
                            " file pattern. The pattern is passed to glob.glob"
                            " function"))

  parser.add_argument("--sampling_method",
                      type=str,
                      default=sampling.DEFAULT_SAMPLING_METHOD,
                      help=("Name of the class used for graph sampling. The"
                            " sampling class must be importable from"
                            " algorithms.sampling module. Defaults to '{0}',"
                            " i.e. algorithms.sampling.{0}."
                            "".format(sampling.DEFAULT_SAMPLING_METHOD)))

  parser.add_argument("--results_base",
                      default="./data/experiment1/samples",
                      type=str,
                      help="Directory to write graphs to.")

  args, unknown = parser.parse_known_args()

  return vars(args)


def parse_recovery_args():
  parser = argparse.ArgumentParser("Experiment 1: Graph recovery")

  parser.add_argument("--seed", type=int, default=None, help="Random seed")

  parser.add_argument("--sample_file_pattern",
                      type=str,
                      default="./data/experiment1/samples/*.json",
                      help=("Run recovery experiment for the graphs/samples"
                            " matching the file pattern. The pattern is passed"
                            " to glob.glob function"))

  parser.add_argument("--recovery_method",
                      type=str,
                      default=recovery.DEFAULT_RECOVERY_METHOD,
                      help=("Name of the class used for graph recovery. The"
                            " recovery class must be importable from"
                            "algorithms.recovery module. Defaults to '{0}',"
                            " i.e. algorithms.recovery.{0}."
                            "".format(recovery.DEFAULT_RECOVERY_METHOD)))

  parser.add_argument("--results_base",
                      default="./data/experiment1/recovery",
                      type=str,
                      help="Directory to write results to.")

  args, unknown = parser.parse_known_args()

  return vars(args)


ARGS_PARSERS = {
  "graph_generate": parse_graph_generate_args,
  "sampling": parse_sampling_args,
  "recovery": parse_recovery_args,
}

def parse_args():
  parser = argparse.ArgumentParser(
    description=(
      "Experiment 1 based on:\n"
      "Basirian, S. and Jung, A., 2017."
      " Random Walk Sampling for Big Data over Networks."
      " arXiv preprint arXiv:1704.04799."))

  parser.add_argument("-v", "--verbose",
                      type=bool_type,
                      default=False,
                      help="Verbose")

  # TODO: add choices for --step
  parser.add_argument("--step",
                      type=str,
                      default="graph_generate",
                      help="Step of the pipeline to run")

  args, unknown = parser.parse_known_args()

  return vars(args)

def run_graph_generate(args):
  print("graph_generate")
  generate_args_base = {
    "sizes": args["cluster_sizes"],
    "p_in": args["p"],
    "p_out": args["q"],
    "seed": args["seed"],
    "cull_disconnected": args["cull_disconnected"],
    "visualize": False,
  }
  num_graphs = args["num_graphs"]
  for i in range(num_graphs):
    out_path = (f"{args['results_base']}"
                f"/{i:0{len(str(num_graphs))-1}}.json")
    generate_args = generate_args_base.copy()
    generate_args.update({"out_path": out_path})

    if args.get('verbose', False):
      print(f"{i}: {generate_args}")

    generate_appm.main(generate_args)

def run_sampling(args):
  print("sampling")

  sampling_args_base = { "seed": args["seed"] }

  num_files = len(glob.glob(args["graph_file_pattern"]))
  for i, filename in enumerate(glob.glob(args["graph_file_pattern"])):
    if i % 100 == 0:
      print("sampling file {}/{}".format(i+1, num_files))
    for L, M in product(args["Ls"], args["Ms"]):
      if args.get('verbose', False):
        print("filename: ", filename)

      sampling_args = sampling_args_base.copy()
      sampling_args.update({
        "graph_file": filename,
        "sampling_method": args["sampling_method"],
        "sampling_params": {
          "L": L,
          "M": M
        },
        "results_file": (f"{args['results_base']}"
                         f"/{L}-{M}-{filename.split('/')[-1]}")
      })

      if args.get('verbose', False):
        print(f"{sampling_args}")

      sampling.main(sampling_args)

def graph_filepath_from_sample_filepath(sample_filepath):
  parts = sample_filepath.split("/")
  graph_folder = "/".join(parts[:-1]).replace("samples", "graphs")
  filename_match = re.search("(\d+-\d+)-(\d+.json)", sample_filepath)
  graph_filename = filename_match.group(2)
  graph_filepath = f"{graph_folder}/{graph_filename}"

  return graph_filepath

def run_recovery(args):
  print("recovery")

  recovery_args_base = {
    "recovery_method": args["recovery_method"],
  }

  results = defaultdict(list)

  num_files = len(glob.glob(args["sample_file_pattern"]))
  for i, sample_filepath in enumerate(glob.glob(args["sample_file_pattern"])):
    if i % 100 == 0:
      print("recovering file {}/{}".format(i+1, num_files))
    if args.get('verbose', False):
      print("sample_filepath: ", sample_filepath)
    # TODO: this is horrible way of handling the graphs and samples
    graph_filepath = graph_filepath_from_sample_filepath(sample_filepath)

    recovery_args = recovery_args_base.copy()
    recovery_args.update({
      "graph_file": graph_filepath,
      "sample_file": sample_filepath,
      "recovery_params": {},
      # "results_file": (f"{args['results_base']}"
      #                  f"/{sample_filepath.split('/')[-1]}")
    })

    if args.get('verbose', False):
      print(f"{recovery_args}")

    result = recovery.main(recovery_args)
    key = tuple(
      int(x) for x in sample_filepath.split('/')[-1].split('-')[:-1]
    )
    results[key].append(result['nmse'])

  from nose.tools import set_trace; set_trace()

def main(args):
  print(args)
  step = args["step"]
  if step == "graph_generate":
    run_graph_generate(args)
  elif step == "sampling":
    run_sampling(args)
  elif step == "recovery":
    run_recovery(args)

if __name__ == "__main__":
  args = parse_args()
  args.update(ARGS_PARSERS[args["step"]]())
  main(args)
